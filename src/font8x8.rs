const fn encode_line(line: &str) -> u8 {
    let bytes = line.as_bytes();
    let mut val = 0u8;
    let mut i = 0;
    while i < bytes.len() && i < 8 {
        let b = bytes[i];
        if b != b' ' && b != b'.' {
            val |= 1 << (7 - i);
        }
        i += 1;
    }
    val
}

const fn encode_lines(lines: [&str; 7]) -> [u8; 8] {
    let mut out = [0u8; 8];
    let mut i = 0;
    while i < 7 {
        out[i] = encode_line(lines[i]);
        i += 1;
    }
    out
}

pub const fn glyph_for(c: char) -> [u8; 8] {
    let ascii = match c {
        'a'..='z' => (c as u8 - 32) as char,
        _ => c,
    };
    match ascii {
        'A' => encode_lines([" .##. ", "#..# ", "#..# ", "#### ", "#..# ", "#..# ", "     "]),
        'B' => encode_lines(["###. ", "#..# ", "###. ", "#..# ", "#..# ", "###. ", "     "]),
        'C' => encode_lines([" .##. ", "#..# ", "#... ", "#... ", "#..# ", " .##. ", "     "]),
        'D' => encode_lines(["###. ", "#..# ", "#..# ", "#..# ", "#..# ", "###. ", "     "]),
        'E' => encode_lines(["#### ", "#... ", "###. ", "#... ", "#... ", "#### ", "     "]),
        'F' => encode_lines(["#### ", "#... ", "###. ", "#... ", "#... ", "#... ", "     "]),
        'G' => encode_lines([" .##. ", "#..# ", "#... ", "#.## ", "#..# ", " .##. ", "     "]),
        'H' => encode_lines(["#..# ", "#..# ", "#### ", "#..# ", "#..# ", "#..# ", "     "]),
        'I' => encode_lines([" ### ", " .#. ", " .#. ", " .#. ", " .#. ", " ### ", "     "]),
        'J' => encode_lines(["  ###", "   #", "   #", "   #", "#..#", " ###", "     "]),
        'K' => encode_lines(["#..# ", "#.#. ", "##.. ", "#.#. ", "#.#. ", "#..# ", "     "]),
        'L' => encode_lines(["#... ", "#... ", "#... ", "#... ", "#... ", "#### ", "     "]),
        'M' => encode_lines(["#..# ", "#### ", "#..# ", "#..# ", "#..# ", "#..# ", "     "]),
        'N' => encode_lines(["#..# ", "##.# ", "#.#. ", "#..# ", "#..# ", "#..# ", "     "]),
        'O' => encode_lines([" .##. ", "#..# ", "#..# ", "#..# ", "#..# ", " .##. ", "     "]),
        'P' => encode_lines(["###. ", "#..# ", "#..# ", "###. ", "#... ", "#... ", "     "]),
        'Q' => encode_lines([" .##. ", "#..# ", "#..# ", "#..# ", "#.## ", " .###", "     "]),
        'R' => encode_lines(["###. ", "#..# ", "#..# ", "###. ", "#.#. ", "#..# ", "     "]),
        'S' => encode_lines([" .###", "#... ", "#... ", " .##", " ...#", "###. ", "     "]),
        'T' => encode_lines(["#### ", " .#. ", " .#. ", " .#. ", " .#. ", " .#. ", "     "]),
        'U' => encode_lines(["#..# ", "#..# ", "#..# ", "#..# ", "#..# ", " .##. ", "     "]),
        'V' => encode_lines(["#..# ", "#..# ", "#..# ", "#..# ", " .##. ", " .##. ", "     "]),
        'W' => encode_lines(["#..# ", "#..# ", "#..# ", "#### ", "#### ", "#..# ", "     "]),
        'X' => encode_lines(["#..# ", "#..# ", " .##. ", " .##. ", "#..# ", "#..# ", "     "]),
        'Y' => encode_lines(["#..# ", "#..# ", " .##. ", " .##. ", " .##. ", " .##. ", "     "]),
        'Z' => encode_lines(["#### ", " ...#", " ..#. ", " .#.. ", "#... ", "#### ", "     "]),
        '0' => encode_lines([" .##. ", "#..# ", "#.#. ", "#..# ", "#..# ", " .##. ", "     "]),
        '1' => encode_lines(["  #  ", " ##  ", "  #  ", "  #  ", "  #  ", " ### ", "     "]),
        '2' => encode_lines([" .##. ", "#..# ", " ...#", " ..#. ", " .#.. ", "#### ", "     "]),
        '3' => encode_lines(["#### ", " ...#", " .## ", " ...#", "#..# ", " .##. ", "     "]),
        '4' => encode_lines(["#..# ", "#..# ", "#### ", " ...#", " ...#", " ...#", "     "]),
        '5' => encode_lines(["#### ", "#... ", "###. ", "...# ", "#..# ", " .##. ", "     "]),
        '6' => encode_lines([" .##. ", "#... ", "###. ", "#..# ", "#..# ", " .##. ", "     "]),
        '7' => encode_lines(["#### ", " ...#", " ..#. ", " .#.. ", " .#.. ", " .#.. ", "     "]),
        '8' => encode_lines([" .##. ", "#..# ", " .##. ", "#..# ", "#..# ", " .##. ", "     "]),
        '9' => encode_lines([" .##. ", "#..# ", "#..# ", " .###", " ...#", " .##. ", "     "]),
        '!' => encode_lines([" .#. ", " .#. ", " .#. ", " .#. ", " ... ", " .#. ", "     "]),
        '?' => encode_lines([" .##. ", "#..# ", " ...#", " ..#. ", " ... ", " ..#. ", "     "]),
        ':' => encode_lines(["     ", " ..  ", " ..  ", "     ", " ..  ", " ..  ", "     "]),
        '.' => encode_lines(["     ", "     ", "     ", "     ", "     ", " ..  ", "     "]),
        ',' => encode_lines(["     ", "     ", "     ", "     ", " ..  ", " ..  ", " ..  "]),
        '-' => encode_lines(["     ", "     ", " ####", "     ", "     ", "     ", "     "]),
        '_' => encode_lines(["     ", "     ", "     ", "     ", "     ", "     ", " ####"]),
        '/' => encode_lines([" ...#", " ..#. ", " ..#. ", " .#.. ", " .#.. ", " #...", "#... "]),
        '>' => encode_lines(["#..  ", " .#. ", " ..#. ", " ...#", " ..#. ", " .#. ", "#..  "]),
        '<' => encode_lines(["  ..#", " .#. ", " .#.. ", " #...", " .#.. ", " .#. ", "  ..#"]),
        '=' => encode_lines(["     ", " ####", "     ", " ####", "     ", "     ", "     "]),
        '+' => encode_lines(["     ", " .#. ", " .#. ", " ### ", " .#. ", " .#. ", "     "]),
        '"' => encode_lines([" # # ", " # # ", "  #  ", "     ", "     ", "     ", "     "]),
        '\'' => encode_lines(["  #  ", "  #  ", "  #  ", "     ", "     ", "     ", "     "]),
        '(' => encode_lines(["   # ", "  #  ", "  #  ", "  #  ", "  #  ", "   # ", "     "]),
        ')' => encode_lines([" #   ", "  #  ", "  #  ", "  #  ", "  #  ", " #   ", "     "]),
        '[' => encode_lines([" ### ", " #   ", " #   ", " #   ", " #   ", " ### ", "     "]),
        ']' => encode_lines([" ### ", "   # ", "   # ", "   # ", "   # ", " ### ", "     "]),
        '{' => encode_lines(["  ## ", " #   ", " #   ", "##   ", " #   ", " #   ", "  ## "]),
        '}' => encode_lines([" ##  ", "   # ", "   # ", "   ##", "   # ", "   # ", " ##  "]),
        '#' => encode_lines([" # # ", "#####", " # # ", "#####", " # # ", " # # ", "     "]),
        '$' => encode_lines(["  #  ", " ####", "# #  ", " ### ", "  # #", "#### ", "  #  "]),
        '%' => encode_lines(["##  #", "## # ", "  #  ", " #   ", " # ##", "#  ##", "     "]),
        '&' => encode_lines([" .## ", "#..# ", " .## ", "##.# ", "#..# ", " ### ", "     "]),
        '*' => encode_lines([" # # ", "  #  ", "#####", "  #  ", " # # ", "     ", "     "]),
        ' ' => [0; 8],
        _ => encode_lines([" ####", "#..# ", " ..# ", " .#  ", " ..  ", " .#  ", "     "]),
    }
}

pub fn render_char(
    buffer: &mut [u8],
    stride: usize,
    px_format: usize,
    bgr: bool,
    x: usize,
    y: usize,
    fg: (u8, u8, u8),
    bg: (u8, u8, u8),
    ch: char,
) {
    let glyph = glyph_for(ch);
    for (row_idx, row) in glyph.iter().enumerate() {
        let y_pos = y + row_idx;
        let mut mask = 0x80u8;
        for col in 0..8 {
            let x_pos = x + col;
            let on = row & mask != 0;
            mask >>= 1;
            let base = (y_pos * stride + x_pos * px_format) as usize;
            if base + 3 > buffer.len() {
                continue;
            }
            let (r, g, b) = if on { fg } else { bg };
            if bgr {
                buffer[base] = b;
                buffer[base + 1] = g;
                buffer[base + 2] = r;
            } else {
                buffer[base] = r;
                buffer[base + 1] = g;
                buffer[base + 2] = b;
            }
        }
    }
}
